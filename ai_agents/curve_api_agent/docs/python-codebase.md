This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-28T22:44:06.044Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
agents/__init__.py
agents/chain_agent.py
agents/revenue_agent.py
tools/__init__.py
tools/chains_tool.py
tools/revenue_tools.py

================================================================
Files
================================================================

================
File: agents/__init__.py
================
"""
Tools package initialization file.
"""

================
File: agents/chain_agent.py
================
from phi.agent import Agent
from tools.chains_tool import (
    get_chain_transactions,
    get_chain_users,
    get_lending_chains,
    get_all_supported_chains,
    get_chain_pools
)
from core.config import llm

# Initialize the chain agent
chain_agent = Agent(
    name="Chain Agent",
    role="Analyze and provide information about blockchain chains using Curve.fi data",
    model=llm,
    tools=[
        get_chain_transactions,
        get_chain_users,
        get_lending_chains,
        get_all_supported_chains,
        get_chain_pools
    ],
    instructions=[
        "Provide accurate chain transaction and user statistics",
        "Format numerical data in tables when possible",
        "Include timestamps with data when available",
        "Explain significant trends or patterns in the data",
    ],
    show_tool_calls=True,
    markdown=True,
)

def get_agent():
    """Returns the initialized chain agent"""
    return chain_agent

================
File: agents/revenue_agent.py
================
from phi.agent import Agent
from tools.revenue_tools import (
    get_fee_distributions,
    get_crvusd_weekly_fees,
    get_pools_weekly_fees,
    get_pending_pool_fees,
    get_cow_settlements,
    get_collected_fees,
    get_staged_fees
)
from core.config import llm

# Create revenue agent with all tools
revenue_agent = Agent(
    name="Curve Revenue Agent",
    role="Retrieve and analyze information about Curve protocol's revenue and fees",
    model=llm,
    tools=[
        get_fee_distributions,
        get_crvusd_weekly_fees,
        get_pools_weekly_fees,
        get_pending_pool_fees,
        get_cow_settlements,
        get_collected_fees,
        get_staged_fees
    ],
    description="""You are a specialized agent for analyzing Curve Protocol's revenue and fees.
    You have access to tools that can fetch:
    - Fee distributions history
    - Weekly crvUSD fees
    - Weekly pool fees
    - Pending pool fees
    - CoW settlements
    - Collected and staged fees
    
    When asked about fees or revenue, always use these tools to provide accurate data.""",
    instructions=[
        "When asked about fee distributions, use get_fee_distributions() first",
        "For weekly fees data, combine crvUSD and pools data when relevant",
        "Always provide numerical analysis of the fee data",
        "Format large numbers for better readability",
        "Explain the significance of fee changes or patterns",
        "If a tool call fails, try with different parameters or use an alternative tool",
        "Present data in a clear, structured format using markdown"
    ],
    show_tool_calls=True,
    markdown=True,
    add_datetime_to_instructions=True
)

================
File: tools/__init__.py
================
"""
Tools package initialization file.
"""

================
File: tools/chains_tool.py
================
"""
Main script
-----------

What: This script allows the LLM to access the v1 chains from the Price Feeds Backend API from Curve.fi

"""
from core.config import APIClient
import logging
from typing import Optional
import requests

# FUNCTIONS
def get_all_supported_chains() -> str:
    """Gets ALL supported chains available on Curve.fi
    
    Returns:
        Formatted string containing chain data
    """
    try:
        logging.info("Fetching supported chains from Curve API...")
        with APIClient() as client:
            response = client.get(endpoint="/v1/chains")
            
            # Format the response as a string
            result = []
            result.append("Supported Chains on Curve.fi")
            result.append("\n")
            
            if 'chains' in response:
                for chain in sorted(response['chains']):
                    result.append(f"- {chain.upper()}")
                    
            return "\n".join(result)
    except requests.RequestException as e:
        return f"API Error: {str(e)}"
    except Exception as e:
        return f"Error: {str(e)}"
    
def get_chain_pools(chain: str, page: int = 1, per_page: int = 10) -> str:
    """Gets all supported contracts/pools for a specific chain on Curve.fi
    
    Args:
        chain (str): The chain name to get pools for (e.g. 'ethereum', 'polygon')
        page (int, optional): Page number for pagination. Defaults to 1.
        per_page (int, optional): Number of results per page. Defaults to 10.
    
    Returns:
        Formatted string containing pool data for the specified chain
    """
    try:
        params = {
            'page': page,
            'per_page': per_page
        }
            
        logging.info(f"Fetching pools for chain {chain} from Curve API...")
        with APIClient() as client:
            response = client.get(
                endpoint=f"/v1/chains/{chain}",
                params=params
            )
            
            # Format the response as a string
            result = []
            result.append(f"Pools on {chain.upper()}")
            result.append(f"Page {response.get('page', 1)} of {(response.get('count', 0) + per_page - 1) // per_page}")
            result.append("\n")
            
            if 'stats' in response:
                stats = response['stats']
                result.append("## Chain Statistics")
                result.append(f"Total TVL: ${stats.get('tvl', 0):,.2f}")
                result.append(f"Daily Volume: ${stats.get('daily_volume', 0):,.2f}")
                result.append("\n")
            
            if 'pools' in response:
                result.append("## Pools")
                for pool in response['pools']:
                    result.append(f"\n### {pool.get('name', 'Unknown Pool')}")
                    result.append(f"Address: {pool.get('address', 'N/A')}")
                    result.append(f"TVL: ${pool.get('tvl', 0):,.2f}")
                    if 'volume' in pool:
                        result.append(f"Volume (24h): ${pool.get('volume', 0):,.2f}")
                    if 'tokens' in pool:
                        result.append("\nTokens:")
                        for token in pool['tokens']:
                            result.append(f"- {token.get('symbol', 'Unknown')}")
            
            return "\n".join(result)
    except requests.RequestException as e:
        return f"API Error: {str(e)}"
    except Exception as e:
        return f"Error: {str(e)}"

def get_chain_transactions(start: Optional[int] = None, end: Optional[int] = None) -> str:
    """Get daily transactions count for each supported chain
    
    Args:
        start (int, optional): Start timestamp for filtering. Defaults to None.
        end (int, optional): End timestamp for filtering. Defaults to None.
    
    Returns:
        Formatted string containing transaction activity data for each chain
    """
    try:
        params = {}
        if start is not None:
            params['start'] = start
        if end is not None:
            params['end'] = end
            
        logging.info("Fetching chain transaction activity...")
        with APIClient() as client:
            response = client.get(
                endpoint="/v1/chains/activity/transactions",
                params=params
            )
            
            # Format the response as a string
            result = []
            result.append("Chain Transaction Activity")
            result.append("\n")
            
            if 'data' in response:
                # Group by chain
                chain_data = {}
                for entry in response['data']:
                    chain = entry.get('chain', 'unknown')
                    if chain not in chain_data:
                        chain_data[chain] = []
                    chain_data[chain].append(entry)
                
                # Format each chain's data
                for chain in sorted(chain_data.keys()):
                    result.append(f"\n## {chain.upper()}")
                    entries = sorted(chain_data[chain], key=lambda x: x.get('timestamp', ''), reverse=True)
                    
                    total_txns = sum(entry.get('transactions', 0) for entry in entries)
                    result.append(f"Total Transactions: {total_txns:,}")
                    
                    result.append("\nDaily Breakdown:")
                    for entry in entries[:7]:  # Show last 7 days
                        result.append(f"- {entry.get('timestamp', 'Unknown')}: {entry.get('transactions', 0):,} transactions")
            
            return "\n".join(result)
    except requests.RequestException as e:
        return f"API Error: {str(e)}"
    except Exception as e:
        return f"Error: {str(e)}"

def get_chain_users(start: Optional[int] = None, end: Optional[int] = None) -> str:
    """Get daily unique user count for each supported chain
    
    Args:
        start (int, optional): Start timestamp for filtering. Defaults to None.
        end (int, optional): End timestamp for filtering. Defaults to None.
    
    Returns:
        Formatted string containing user activity data for each chain
    """
    try:
        params = {}
        if start is not None:
            params['start'] = start
        if end is not None:
            params['end'] = end
            
        logging.info("Fetching chain user activity...")
        with APIClient() as client:
            response = client.get(
                endpoint="/v1/chains/activity/users",
                params=params
            )
            
            # Format the response as a string
            result = []
            result.append("Chain User Activity")
            result.append("\n")
            
            if 'data' in response:
                # Group by chain
                chain_data = {}
                for entry in response['data']:
                    chain = entry.get('chain', 'unknown')
                    if chain not in chain_data:
                        chain_data[chain] = []
                    chain_data[chain].append(entry)
                
                # Format each chain's data
                for chain in sorted(chain_data.keys()):
                    result.append(f"\n## {chain.upper()}")
                    entries = sorted(chain_data[chain], key=lambda x: x.get('timestamp', ''), reverse=True)
                    
                    total_users = sum(entry.get('users', 0) for entry in entries)
                    result.append(f"Total Unique Users: {total_users:,}")
                    
                    result.append("\nDaily Breakdown:")
                    for entry in entries[:7]:  # Show last 7 days
                        result.append(f"- {entry.get('timestamp', 'Unknown')}: {entry.get('users', 0):,} users")
            
            return "\n".join(result)
    except requests.RequestException as e:
        return f"API Error: {str(e)}"
    except Exception as e:
        return f"Error: {str(e)}"

def get_lending_chains() -> str:
    """Get all supported chains for lending stats
    
    Returns:
        Formatted string containing list of supported chains for lending
    """
    try:
        logging.info("Fetching supported lending chains...")
        with APIClient() as client:
            response = client.get(endpoint="/v1/lending/chains/")
            
            # Format the response as a string
            result = []
            result.append("Supported Lending Chains")
            result.append("\n")
            
            if 'chains' in response:
                for chain in sorted(response['chains']):
                    result.append(f"- {chain.upper()}")
                    if 'stats' in response and chain in response['stats']:
                        stats = response['stats'][chain]
                        result.append(f"  TVL: ${stats.get('tvl', 0):,.2f}")
                        result.append(f"  Total Borrowed: ${stats.get('total_borrowed', 0):,.2f}")
                        result.append(f"  Available Liquidity: ${stats.get('available_liquidity', 0):,.2f}")
            
            return "\n".join(result)
    except requests.RequestException as e:
        return f"API Error: {str(e)}"
    except Exception as e:
        return f"Error: {str(e)}"

================
File: tools/revenue_tools.py
================
import logging
from typing import Optional, Dict, Any
from core.config import APIClient

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

def get_fee_distributions(page: int = 1, per_page: int = 10) -> str:
    """
    Get historical fee distributions with pagination
    
    Args:
        page (int): Page number for pagination (default: 1)
        per_page (int): Number of items per page (default: 10)
        
    Returns:
        Formatted string containing fee distribution data
    """
    logger.info(f"Fetching fee distributions for page {page} with {per_page} items per page")
    
    params = {
        "page": page,
        "per_page": per_page
    }
    
    with APIClient() as client:
        response = client.get("/v1/dao/fees/distributions", params=params)
        
        # Format the response as a string
        result = []
        result.append(f"Fee Distributions (Page {response['page']}, Total: {response['count']})")
        result.append("\n")
        
        for dist in response['distributions']:
            result.append("---")
            for key, value in dist.items():
                result.append(f"{key}: {value}")
            result.append("\n")
            
        return "\n".join(result)

def get_crvusd_weekly_fees(start: Optional[int] = None, end: Optional[int] = None) -> str:
    """
    Get weekly fees (including currently pending) from crvUSD markets
    
    Args:
        start (int, optional): Start timestamp
        end (int, optional): End timestamp
        
    Returns:
        Formatted string containing weekly crvUSD fees data
    """
    logger.info(f"Fetching crvUSD weekly fees from {start} to {end}")
    
    params = {}
    if start is not None:
        params["start"] = start
    if end is not None:
        params["end"] = end
        
    with APIClient() as client:
        response = client.get("/v1/dao/fees/crvusd/weekly", params=params)
        
        # Format the response as a string
        result = []
        result.append("Weekly crvUSD Fees")
        result.append("\n")
        
        # Group fees by timestamp for better readability
        fees_by_date = {}
        for fee in response['fees']:
            timestamp = fee['timestamp']
            if timestamp not in fees_by_date:
                fees_by_date[timestamp] = []
            fees_by_date[timestamp].append(fee)
        
        # Format each date's fees
        for timestamp, fees in sorted(fees_by_date.items(), reverse=True):
            result.append(f"\n## {timestamp}")
            total_fees = sum(fee['fees_usd'] for fee in fees)
            result.append(f"Total Fees: ${total_fees:,.2f}")
            
            for fee in fees:
                result.append(f"\n- {fee['collateral']}")
                result.append(f"  Fees: ${fee['fees_usd']:,.2f}")
                result.append(f"  Controller: {fee['controller']}")
            
        return "\n".join(result)

def get_pools_weekly_fees(start: Optional[int] = None, end: Optional[int] = None) -> str:
    """
    Get weekly fees (including currently pending) from pools across all chains
    
    Args:
        start (int, optional): Start timestamp
        end (int, optional): End timestamp
        
    Returns:
        Formatted string containing weekly pool fees data
    """
    logger.info(f"Fetching pools weekly fees from {start} to {end}")
    
    params = {}
    if start is not None:
        params["start"] = start
    if end is not None:
        params["end"] = end
        
    with APIClient() as client:
        response = client.get("/v1/dao/fees/pools/weekly", params=params)
        
        # Format the response as a string
        result = []
        result.append("Weekly Pool Fees Across Chains")
        result.append("\n")
        
        # Group fees by chain and timestamp
        fees_by_chain = {}
        for fee in response['fees']:
            chain = fee.get('chain', 'unknown')
            if chain not in fees_by_chain:
                fees_by_chain[chain] = {}
            
            timestamp = fee.get('timestamp')
            if timestamp not in fees_by_chain[chain]:
                fees_by_chain[chain][timestamp] = []
            fees_by_chain[chain][timestamp].append(fee)
        
        # Format each chain's fees
        for chain in sorted(fees_by_chain.keys()):
            result.append(f"\n# {chain.upper()}")
            
            for timestamp in sorted(fees_by_chain[chain].keys(), reverse=True):
                fees = fees_by_chain[chain][timestamp]
                result.append(f"\n## {timestamp}")
                total_chain_fees = sum(fee.get('fees_usd', 0) for fee in fees)
                result.append(f"Total Chain Fees: ${total_chain_fees:,.2f}")
                
                for fee in fees:
                    result.append(f"\n- Pool: {fee.get('pool_name', 'Unknown Pool')}")
                    result.append(f"  Fees: ${fee.get('fees_usd', 0):,.2f}")
                    if 'volume_usd' in fee:
                        result.append(f"  Volume: ${fee.get('volume_usd', 0):,.2f}")
            
        return "\n".join(result)

def get_pending_pool_fees(chain: str) -> str:
    """
    Get pending admin fees on all pools for a specific chain
    
    Args:
        chain (str): Chain identifier (e.g., "ethereum", "polygon")
        
    Returns:
        Formatted string containing pending pool fees data
    """
    logger.info(f"Fetching pending pool fees for chain: {chain}")
    
    with APIClient() as client:
        response = client.get(f"/v1/dao/fees/{chain}/pending")
        
        # Format the response as a string
        result = []
        result.append(f"Pending Pool Fees for {chain.upper()}")
        result.append("\n")
        
        if 'data' in response:
            total_pending_usd = sum(pool.get('pending_fees_usd', 0) for pool in response['data'])
            result.append(f"Total Pending Fees: ${total_pending_usd:,.2f}\n")
            
            # Sort pools by pending fees
            sorted_pools = sorted(
                response['data'], 
                key=lambda x: x.get('pending_fees_usd', 0), 
                reverse=True
            )
            
            for pool in sorted_pools:
                result.append(f"\n## {pool.get('name', 'Unknown Pool')}")
                result.append(f"Pending Fees: ${pool.get('pending_fees_usd', 0):,.2f}")
                if 'tokens' in pool:
                    result.append("\nToken Breakdown:")
                    for token in pool['tokens']:
                        result.append(f"- {token.get('symbol', 'Unknown')}: {token.get('amount', 0)}")
                        if 'usd_value' in token:
                            result.append(f"  (${token.get('usd_value', 0):,.2f})")
        
        return "\n".join(result)

def get_cow_settlements(timestamp: Optional[int] = None) -> str:
    """
    Get information on the latest settlements of fees via CoWSwap
    
    Args:
        timestamp (int, optional): Unix timestamp to filter settlements
        
    Returns:
        Formatted string containing CoWSwap settlement data
    """
    logger.info(f"Fetching CoWSwap settlements before timestamp: {timestamp}")
    
    params = {}
    if timestamp is not None:
        params["timestamp"] = timestamp
        
    with APIClient() as client:
        response = client.get("/v1/dao/fees/settlements", params=params)
        
        # Format the response as a string
        result = []
        result.append("CoWSwap Fee Settlements")
        result.append("\n")
        
        if 'settlements' in response:
            for settlement in response['settlements']:
                result.append("\n---")
                result.append(f"Timestamp: {settlement.get('timestamp', 'Unknown')}")
                result.append(f"Transaction: {settlement.get('tx_hash', 'Unknown')}")
                
                if 'tokens' in settlement:
                    result.append("\nTokens Settled:")
                    for token in settlement['tokens']:
                        result.append(f"- {token.get('symbol', 'Unknown')}")
                        result.append(f"  Amount: {token.get('amount', 0)}")
                        if 'usd_value' in token:
                            result.append(f"  Value: ${token.get('usd_value', 0):,.2f}")
                
                if 'total_usd' in settlement:
                    result.append(f"\nTotal Value: ${settlement.get('total_usd', 0):,.2f}")
        
        return "\n".join(result)

def get_collected_fees() -> str:
    """
    Get the list of tokens collected in the Fee Collector
    
    Returns:
        Formatted string containing collected fees data
    """
    logger.info("Fetching collected fees from Fee Collector")
    
    with APIClient() as client:
        response = client.get("/v1/dao/fees/collected")
        
        # Format the response as a string
        result = []
        result.append("Collected Fees in Fee Collector")
        result.append("\n")
        
        if 'data' in response:
            total_usd = sum(token.get('usd_value', 0) for token in response['data'])
            result.append(f"Total Value: ${total_usd:,.2f}\n")
            
            # Sort tokens by USD value
            sorted_tokens = sorted(
                response['data'],
                key=lambda x: x.get('usd_value', 0),
                reverse=True
            )
            
            for token in sorted_tokens:
                result.append(f"\n## {token.get('symbol', 'Unknown Token')}")
                result.append(f"Amount: {token.get('amount', 0):,.6f}")
                if 'usd_value' in token:
                    result.append(f"Value: ${token.get('usd_value', 0):,.2f}")
        
        return "\n".join(result)

def get_staged_fees() -> str:
    """
    Get the list of tokens collected in the Fee Burner
    
    Returns:
        Formatted string containing staged fees data
    """
    logger.info("Fetching staged fees from Fee Burner")
    
    with APIClient() as client:
        response = client.get("/v1/dao/fees/staged")
        
        # Format the response as a string
        result = []
        result.append("Staged Fees in Fee Burner")
        result.append("\n")
        
        if 'data' in response:
            total_usd = sum(token.get('usd_value', 0) for token in response['data'])
            result.append(f"Total Value: ${total_usd:,.2f}\n")
            
            # Sort tokens by USD value
            sorted_tokens = sorted(
                response['data'],
                key=lambda x: x.get('usd_value', 0),
                reverse=True
            )
            
            for token in sorted_tokens:
                result.append(f"\n## {token.get('symbol', 'Unknown Token')}")
                result.append(f"Amount: {token.get('amount', 0):,.6f}")
                if 'usd_value' in token:
                    result.append(f"Value: ${token.get('usd_value', 0):,.2f}")
        
        return "\n".join(result)
